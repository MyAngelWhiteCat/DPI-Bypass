# Инструмент для **тестирования и оценки устойчивости** систем глубокой инспекции пакетов

Данный инструментарий предоставляет методы для **тестирования эффективности** DPI систем путем симуляции различных техник обхода. Разработан для исследователей безопасности, сетевых инженеров и разработчиков DPI систем для **оценки устойчивости** систем проверки пакетов. Выполнен в виде С++ класса для простой интеграции в любое С++ приложение.

[Скачать](https://github.com/MyAngelWhiteCat/DPI-Bypass/releases/latest) версию с реализованной эмуляцией атаки на DPI анализирующий трафик к сервисам youtube, osu.direct, catboy.best, api.nerinyan.moe - зеркала для загрузки Osu! карт и текстовых каналов dicord можно [по ссылке](https://github.com/MyAngelWhiteCat/DPI-Bypass/releases/latest)


## Основные сценарии использования:
- **Тестирование** возможностей детектирования DPI систем
- **Исследование** методов обхода проверки пакетов
- **Образовательные цели** в области сетевой безопасности
- Разработка и валидация контрмер для DPI систем


## Техническая реализация

Инструмент работает на уровне сетевого драйвера с использованием WinDivert для перехвата и модификации исходящих TLS пакетов. Реализованы несколько техник модификации TLS рукопожатий для тестирования устойчивости DPI систем.

## Методологии тестирования

### 1. **Простая подмена SNI**
Отправляет поддельный Client Hello пакет с SNI `www.google.com` перед реальным соединением. Тестирует базовые системы проверки первых пакетов.

### 2. **Множественная подмена SNI**
Отправляет несколько (по умолчанию: 6) поддельных Client Hello пакетов. Оценивает системы, анализирующие несколько начальных пакетов.

### 3. **Фрагментация SNI**
Дробит полезную нагрузку TLS пакета и отправляет по частям. Тестирует способность DPI систем собирать и проверять фрагментированный трафик.

### 4. **Комбинированная подмена и фрагментация**
Гибридный подход: несколько поддельных пакетов + фрагментация с добавлением мусорных данных. Тестирует продвинутые DPI системы с глубокой проверкой пакетов.


### Для разработчиков DPI систем:
Тестируйте вашу DPI систему против реализованных, популярных техник обхода
```cpp
bypasser.AddBypassRequiredHostname("www.youtube.com", BypassMethod::SSF_FAKED_SPLIT);
bypasser.AddBypassRequiredHostname("googlevideo.com", BypassMethod::SIMPLE_SNI_FAKE);
...
```
Учитывайте, что проверяется не только сам домен, но и производные от него.

## Добавление новых методов в 4 простых шага
1. Добавьте новый enum в BypassMethod:
```cpp
enum class BypassMethod {
    NON = 0,
    SIMPLE_SNI_FAKE = 1,
    MULTI_SNI_FAKE = 2,
    SSF_FAKED_SPLIT = 3
    //...
};
```
2. Реализуйте метод в классе DPIBypasser:
```cpp
class DPIBypasser {
    ...
    void YourNewMethod();
    ...
};
```

3. Добавьте обработку в метод Bypass():
```cpp
case BypassMethod::YOUR_NEW_METHOD:
    YourNewMethod();
    return;
```

4. Используйте ваш метод:
```cpp
bypasser.AddBypassRequiredHostname("test.com", BypassMethod::YOUR_NEW_METHOD);
```

## Установка и сборка
Перед сборкой установите драйвер WinDivert:

```bash
windivert_install.bat
```
(Запустите от имени администратора)

Убедитесь что файлы WinDivert64.sys, WinDivert.dll, WinDivert.lib и windivert.h находятся в папке проекта.
Соберите с помощью CMake:

```bash
mkdir build && cd build
cmake ..
cmake --build . --config Release
```
Использование

Убедитесь, что файлы tls_clienthello_www_google_com.bin и WinDivert.dll находятся рядом с DPIbypass.exe
Запустите программу от имени администратора:

```bash
DPIbypass.exe
```

### Правовые и этические аспекты использования
#### Данный инструмент предназначен для:
- Авторизованного тестирования безопасности
- Академических исследований
- Разработки и оценки DPI систем
- Образовательных целей

#### Не предназначен для:

- Несанкционированного вмешательства в сетевую инфраструктуру
- Обхода законных средств контроля безопасности
- Незаконной деятельности

Всегда убеждайтесь в наличии надлежащих разрешений перед тестированием любых сетевых систем.
